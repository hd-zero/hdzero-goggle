#include "uart.h"
#include <errno.h>
#include <errno.h> /* ERROR Number Definitions           */
#include <fcntl.h>
#include <fcntl.h> /* File Control Definitions           */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <termios.h>
#include <termios.h> /* POSIX Terminal Control Definitions */
#include <unistd.h>
#include <unistd.h> /* UNIX Standard Definitions 	   */

static char *uart_ports[UART_PORTS] = {
    "/dev/ttyS0",
    "/dev/ttyS1",
    "/dev/ttyS2",
    "/dev/ttyS3",
};

int uart_set_opt(int fd, int nSpeed, int nBits, char nEvent, int nStop) {
    struct termios newtio, oldtio;
    if (tcgetattr(fd, &oldtio) != 0) {
        perror("SetupSerial 1");
        return -1;
    }
    bzero(&newtio, sizeof(newtio));
    newtio.c_cflag |= CLOCAL | CREAD;
    newtio.c_cflag &= ~CSIZE;

    switch (nBits) {
    case 7:
        newtio.c_cflag |= CS7;
        break;
    case 8:
        newtio.c_cflag |= CS8;
        break;
    }

    switch (nEvent) {
    case 'O':
        newtio.c_cflag |= PARENB;
        newtio.c_cflag |= PARODD;
        newtio.c_iflag |= (INPCK | ISTRIP);
        break;
    case 'E':
        newtio.c_iflag |= (INPCK | ISTRIP);
        newtio.c_cflag |= PARENB;
        newtio.c_cflag &= ~PARODD;
        break;
    case 'N':
        newtio.c_cflag &= ~PARENB;
        break;
    }

    switch (nSpeed) {
    case 2400:
        cfsetispeed(&newtio, B2400);
        cfsetospeed(&newtio, B2400);
        break;
    case 4800:
        cfsetispeed(&newtio, B4800);
        cfsetospeed(&newtio, B4800);
        break;
    case 9600:
        cfsetispeed(&newtio, B9600);
        cfsetospeed(&newtio, B9600);
        break;
    case 115200:
        cfsetispeed(&newtio, B115200);
        cfsetospeed(&newtio, B115200);
        break;
    case 230400:
        cfsetispeed(&newtio, B230400);
        cfsetospeed(&newtio, B230400);
        break;
    case 460800:
        cfsetispeed(&newtio, B460800);
        cfsetospeed(&newtio, B460800);
        break;
    default:
        cfsetispeed(&newtio, B9600);
        cfsetospeed(&newtio, B9600);
        break;
    }
    if (nStop == 1)
        newtio.c_cflag &= ~CSTOPB;
    else if (nStop == 2)
        newtio.c_cflag |= CSTOPB;
    newtio.c_cc[VTIME] = 0;
    newtio.c_cc[VMIN] = 0;
    tcflush(fd, TCIFLUSH);
    if ((tcsetattr(fd, TCSANOW, &newtio)) != 0) {
        perror("com set error");
        return -1;
    }
    return 0;
}

int uart_read(int fd, uint8_t *data, int len) {

    int bytes_read = 0; /* Number of bytes read by the read() system call */

    bytes_read = read(fd, data, len); /* Read the data                   */
    return bytes_read;
}

int uart_write(int fd, uint8_t *data, int len) {
    int bytes_written = 0; /* Value for storing the number of bytes written to the port */

    bytes_written = write(fd, data, len); /* use write() to send data to port */
    return bytes_written;
}

void uart_close(int fd) {
    close(fd);
}

int uart_open(int port_num) {
    char *port = uart_ports[port_num];
    int fd = open(port, O_RDWR);
    if (fd < 0) {
        return -1;
    }
    uart_set_opt(fd, 115200, 8, 'N', 1);
    return fd;
}

int uart_read_byte(int fd, uint8_t *data) {
    return uart_read(fd, data, 1);
}

int uart_write_byte(int fd, uint8_t data) {
    return uart_write(fd, &data, 1);
}
